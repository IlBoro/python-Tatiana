1. Идея была в следующем , так как мы принимаем, числа в формате (x,y) но в пайтон индексация идет 
в стиле (y, x), то мы разворачиваем входные данные и меняем местами.

2. Потом инициализируем route с первым значением кортежа стартовой точки. 

3. Вытягиваем координаты рек(но вообще можно делать и по другому просто сравнивать что  например следующая потенциальная точка не имеет значение 0 )

4. Функция check move проверяет 4 кейса для движения по столбцам и по рекам:
 - принимает текущую точку где мы находимся
 - потом принимает вторым параметром изменение индекса столбца или ряда, 
 - принимает список рек, 
 - принимает строку row или column для проверки по каким направлениям мы можем идти
 
5. Потом  инициализируем список  moves, где будем сохранять шаги которые мы сделали чтобы не повторять те шаги которые приводят нас к движению на одном месте , так как мы определили далее выбор шага в зависимости от приближения к таргету, но все дело в том что у нас таргет , по этой проверке может быть на самом деле очень близко, но окружен реками в направлении наименьших шагов и нам сначала нужно будет наоборот идти в совершенно других направлениях чтобы выбраться с лабиринта(если мы не можем конечно дойти к целевой точке напрямую)
   
6. Потом в глобальном  while нужно  сделать цикл в стиле пока мы не достигли поинта по двум направлениям мы продолжаем движение, но нужно это реализовать как то так, чтобы если мы например с текущей точки не можем двигатья ни вправо ни влево , то мы  переходим к движению вверх вниз, даже 
если мы ещё не достигли нужной точки при движении по столбцам , смещаемся  по рядам , потом оказывается что мы снова не можем по ним двигаться , снова пытаемся двигаться по рядам. 

7. В итоге после таких попыток мы были бы должны дойти до нашей точки, но проблема вот в чем 
мы таким образом делаем очень много движений, так как мы сначала можем пойти к тупику в виде  нулевых
значений, потом нам нужно будет разворачиваться , идти в обратном направлении и так далее и проблема 
в том что таких кейсов может быть много в зависимости от сложности лабиринта от стартовой точки к нужной. 

Поэтому нужно улучшить некоторые моменты в коде что то добавить чтобы сделать его более эфективным 